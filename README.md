# Ход работы
### 1.	Установка и подготовка среды  
Работа выполнялась в среде Ubuntu 22.04.  
Установлены следующие инструменты:  
●	 clang — компилятор языка C/C++;  
●	llvm — инструменты анализа и оптимизации кода;  
●	opt — инструмент для работы с LLVM IR и применения оптимизаций;  
●	Graphviz — инструмент для визуализации кода.  
Команда установки: `sudo apt install clang llvm`  

![1](https://github.com/user-attachments/assets/386a87fe-5559-4a5c-a620-bf94858c78a5)  

### 2.	Исходный код  
Программа на языке C:  
#include <stdio.h>
int square(int x) { return x * x;
}
int main() {
 
int a = 5;
int b = square(a); printf("%d\n", b); return 0;
}  
Сохранена в файл main.c.  

![2](https://github.com/user-attachments/assets/bbe533b0-d601-404e-9320-0c92def26b33)  

### 3.	Получение AST  
Команда: `clang -Xclang -ast-dump -fsyntax-only main.c`  

![3(2)](https://github.com/user-attachments/assets/3cae1821-40c0-40ae-b308-d58d161095a4)  

Функция square принята, содержит параметр x и возвращает x * x.  

### 4.	Генерация LLVM IR  
Команда: `clang -S -emit-llvm main.c -o main.ll`  

![4](https://github.com/user-attachments/assets/7340f050-0883-4d7b-9d03-bc61f51002fe)  

### 5.	Оптимизация IR  
Команда: `clang -O0 -S -emit-llvm main.c -o main_O0.ll`  
Стоит отметить, что в файле с IR до оптимизации:  
Все переменные (a, b, x.addr) размещены в памяти через alloca;  
Множество операций load и store;  
square вызывается как отдельная функция.  

![5](https://github.com/user-attachments/assets/e2ab5ba7-0844-4712-9142-3a03fdbfa6f8)  

Команда: `clang -O2 -S -emit-llvm main.c -o main_O2.ll`  
 
Команда -O2 – комплексная оптимизация среднего уровня. Она применяет более 30 различных оптимизаций:  
●	-inline – встраивание небольших функций (встраивает square в main, если она вызывается один раз);  
●	-constprop – подставит значение square(5) → 25, если функция встроена и всё известно на этапе компиляции;  
●	-mem2reg – перевод переменных из памяти в регистры (SSA);  
●	-instcombine – объединение и упрощение инструкций (упростит арифметику, например x * x может быть преобразовано в shl при x = 2^n);  
●	-simplifycfg – оптимизирует структуру блоков (Упростит граф управления, если после inlining останутся лишние блоки);  
●	-reassociate, -gvn, -sroa, -dce и другие.  
В файле с IR после оптимизации:  
Вся функция square исчезла – она была встроена (-inline) и затем вычислена (оптимизация -constprop);  
Никаких переменных, alloca, store, load – всё удалено (оптимизации -mem2reg, -dce);  
Остался только вызов printf(25).  

![5(2)](https://github.com/user-attachments/assets/73172830-9f3f-42a9-af26-7f106d9b9fd8)  

Команда: `diff main_O0.ll main_O2.ll`  
Сравнение двух файлов:  
 
![5(3)](https://github.com/user-attachments/assets/32d1ab79-a333-4ccd-9e59-fe22a63576b8)  

![5(3_2)](https://github.com/user-attachments/assets/9fdbfdbc-0573-4329-973e-9cd80f4452cc)  

Стоит отметить, что после оптимизации произошли следующие изменения:  
●	Переменные типа alloca были удалены;  
●	Код переведён в SSA-форму;  
●	Оптимизация	улучшила	читаемость	и	упростила	поток управления.  

### 6.	Граф потока управления программы  
Команда для генерации оптимизированного LLVM IR: `clang -O2 -S -emit-llvm main.c -o main.ll`  
Команда для генерации .dot-файлов CFG для функций: `opt -dot-cfg -disable-output main.ll`  

Эта команда создаст DOT-файлы:   
.main.dot – для функции main;  
.square.dot – для square, если она не была удалена оптимизацией.  
Команда для установки библиотеки Graphviz: `sudo apt install graphviz`  
 
Команды для преобразования файлов с расширением .dot в .png с помощью Graphviz: `dot -Tpng .main.dot -o cfg_main.png dot -Tpng .square.dot -o cfg_square.png`  
Команды для просмотра файлов с CGF:  
`xdg-open cfg_main.png`  

![6](https://github.com/user-attachments/assets/13320ed1-7308-4e83-8690-d9358ac3dda4)  

`xdg-open cfg_square.png`  

![7](https://github.com/user-attachments/assets/a602ef46-f393-4572-ad11-714b3f61b39d)  

Стоит отметить, что в LLVM каждый граф потока управления (CFG) строится на уровне функции, поскольку структура управления всегда локальна для тела функции. Для получения полного представления о программе, нужно построить CFG для всех функций и анализировать их совокупность. Автоматическое объединение всех CFG в один граф не предусмотрено в LLVM по умолчанию.  

# Выводы  
●	С помощью Clang можно получить полную структуру AST и IR, а также CGF;  
●	LLVM	предоставляет	гибкие	инструменты	анализа	и оптимизации;  
●	Промежуточное представление кода удобно для написания компиляторных трансформаций.  

# Ответы на контрольные вопросы  
### 1.	Что такое Clang, и какова его роль в процессе компиляции программ?  
Clang — это современный компилятор для C-подобных языков, созданный для работы на базе LLVM. Его роль в процессе компиляции:
Читает код; Проверяет на ошибки; Преобразует в промежуточный код (IR); С помощью LLVM создаёт быстрый исполняемый файл.  

### 2.	Что	представляет	собой	LLVM	и как он используется в современных компиляторах?  
LLVM -  набор инструментов для создания компиляторов. Он помогает преобразовывать код с одного уровня (например, C++) на другой (машинный) и предоставляет инфраструктуру для анализа, оптимизации и генерации кода.  

### 3.	Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?  
AST (абстрактное синтаксическое дерево) — показывает структуру кода (что написано и как связано), используется на раннем этапе компиляции.  
LLVM IR — это низкоуровневое промежуточное представление, близкое к машинному коду, используется для оптимизации и генерации исполняемого файла.  

### 4.	Для чего необходимо промежуточное представление (IR) в процессе компиляции?  
1) Упрощать оптимизацию кода перед переводом в машинный.
2) Разделять компиляцию на этапы — сначала из языка → в IR, потом IR → в машинный код.  
3) Облегчать переносимость — один IR можно превратить в код для разных платформ.
4) Упрощать анализ и отладку — IR проще, чем исходный код или машинный.  

### 5.	Что	делает	инструкция	alloca	в	LLVM	IR,	и	зачем	она используется в функциях?  
 alloca — это инструкция, которая выделяет память на стеке для переменной внутри функции. Она нужна, чтобы создать локальную переменную и автоматически освобождить память, когда функция завершается.  

### 6.	Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?  
 1) Ускорить выполнение программы  
2) Уменьшить размер кода (удалить лишнее, объединить повторяющееся)  
3) Снизить потребление памяти и ресурсов (лучше использовать переменные, не хранить лишнее)  

### 7.	Что такое SSA-форма и почему она важна при оптимизации программ?  
   SSA — это форма представления кода, где каждая переменная присваивается ровно один раз.  
1) Упрощает анализ и оптимизацию кода — легче отслеживать, откуда берутся значения.  
2) Позволяет компилятору делать более эффективные преобразования, например, устранение повторных вычислений и мёртвого кода.  
3) Делает алгоритмы оптимизации проще и быстрее.  

### 8.	Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?
   Граф потока управления (CFG) — это схема, которая показывает, как выполняется программа: из какого участка кода (блока) в какой следующий можно перейти.
  	1) Показывает все возможные пути выполнения  
2) Позволяет находить мёртвый код  
3) Помогает оптимизировать и улучшать безопасность (например, проверять циклы и условия)  
4) Используется для построения точного анализа переменных и эффектов  

### 9.	Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?
   Сложение: `%result = add i32 %a, %b`  
  	Умножение: `%result = mul i32 %a, %b`  
  	Для чисел с плавающей точкой используются аналогичные инструкции с приставкой f: `%result = fadd float %x, %y`  

### 10.	Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?  
   Потому что они облегчают локальный анализ и оптимизацию; позволяют компилятору фокусироваться на одной функции за раз для улучшения производительности; облегчают повторное использование и инлайнинг функций; помогают управлять сложностью и масштабируемостью оптимизаций.  

### 11.	Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?  
   Компилятор обычно встраивает её тело прямо в место вызова — это называется инлайнинг. Он позволяет лучше оптимизировать объединённый код (например, убрать лишние переменные) и улучшает производительность программы.  

### 12.	Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?  
1) IR — единый формат, независимый от исходного языка, упрощает анализ и оптимизацию.  
2) IR ближе к машинному коду, что позволяет точнее оценивать производительность и ресурсы.  
3) CFG показывает все пути выполнения, включая ветвления и циклы — это невозможно точно сделать, просто читая C.  
4) IR и CFG позволяют эффективно отслеживать зависимости, значения переменных и влияние инструкций.  
5) Оптимизации на IR/CFL-уровне проще применять многократно и в разном порядке, без необходимости повторного парсинга исходника.  

# Дополнительное задание: вариант 7
Задание: Создайте char msg[] = "Hello"; и выведите msg[1]. Посмотрите, как Clang хранит строку в IR и как обращается к символам.  
Исходный код:  
#include <stdio.h>  
int main() {  
    char msg[] = "Hello";  
    printf("%c\n", msg[1]);  
    return 0;  
}  
Помещаем в файл dop.c  
![11](https://github.com/user-attachments/assets/8eb4a8cb-d30e-4ba8-a304-ef986489f589)

Командой `clang -S -emit-llvm dop.c -o dop.ll` компилируем код с генерацией LLVM IR.  

![12](https://github.com/user-attachments/assets/41d71c91-939f-4d37-b6a2-21aaaa5ad0cd)  

`@__const.main.msg = constant [6 x i8] c"Hello\00"`  
`@.str = constant [4 x i8] c"%c\0A\00"`  
"Hello\00" — это строка, которая копируется в локальный массив msg.  
"%c\n" — формат для printf, напечатать символ.  

`%2 = alloca [6 x i8], align 1`  
Выделяет место в стеке под массив msg[6].  

`call void @llvm.memcpy.p0i8.p0i8.i64(
  i8* %3,                     ;
  i8* getelementptr @__const.main.msg, ;
  i64 6,                      ;
  i1 false
)`  
Копирует строку "Hello" в msg.  

`%4 = getelementptr [6 x i8], [6 x i8]* %2, i64 0, i64 1`  
`%5 = load i8, i8* %4`  
getelementptr вычисляет адрес msg[1].  
load загружает символ 'e'.  

`%6 = sext i8 %5 to i32`  
`%7 = call i32 (i8*, ...) @printf(i8* ..., i32 %6)`  
Расширяет тип с i8 до i32 (так требует printf).  
Вызывает printf с символом.  
